<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 FINAL//EN">
<HTML>
<HEAD>
<TITLE>Project JEDI Knowledgebase Article</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFFF" LINK="#993366" VLINK="#006699" TEXT="#000000" TOPMARGIN=0 LEFTMARGIN=0 MARGINWIDTH=0 MARGINHEIGHT=0>
<span style="font-family:Verdana;font-size:12pt;">
<table width="85%">
  <tr>
    <td>
      <table>
        <tr>
          <td width=145 valign="middle">
<a href="articles.html">
<img src="img/jedi-articles.gif" width=140 height=38 border=0></a>
          </td>
          <td>
<font color="483d8b">
<h2>A Project JEDI Software Engineering Tool Suite Project</h2></font>
          </td>
        </tr>
      </table>
    </td>
  </tr>
  <tr>
    <td align="center">  
<b>&copy; Nicole Boivin</a></b>
<br>&nbsp;
    </td>
  </tr>
</table>


<table width="85%">
  <tr>
    <td>
    <!-- White margin at left -->

      <table>  
        <tr>
          <td width="10">
          <img src="img/clearpixel.gif" width="10">
          </td>
<!--  Main body -->
          <td>
<!-- --------------------------- -->
            <table>
              <tr>
                <td>
<!-- --------------------------- -->

<P>By way of introduction,  I am an electrical engineer and have worked with many computer languages and database systems over the years. I currently manage a software maintenance and development facility. Long ago I settled on Pascal as my language of choice, for its clarity, readability and reliability. And of course Borland builds the best compilers. <P>
When Delphi came along I fell in love (don't let my husband Tomas hear that !). I am also a partner with my husband in a software consulting business, DigitalPuppet, which develops data backend websites and engineering software applications, mostly for an Aerospace company here. Anyway, I am a strong supporter of Delphi. </P>

<h3>Software Engineering</h3>

<P>I don't want to bore you with history and theory you probably already know. Treating software as an engineering discipline rather than an art form is a movement which traces back to the early 70's and a disastrous experience of a project manager at IBM. Since then it has been the subject of study of academia and research abounds. The fact is that over 90% of big software projects fail to come in on time, on budget and with full functionality, if they deliver at all. </P>

<P>The military have been very interested in this subject. The US DoD came up with a set of standards for software documentation as a means of monitoring and assuring quality on big contracts, Mil-Std-2167A which incidentally is now deprecated. The US DoD also mandated the use of the Ada programming language. By the way, Ada is a Pascal derivative only 'nit picky' and with crummy tools. Like other grandios schemes (PL/1 comes to mind), Ada never caught in the commercial market, although some die hards are still using it. I observed it didn't produce a better product. It sure produced an expensive one though. Documentation is very expensive. Ada is expensive. </P>

<P>The fallacy of the 2167A standards is that they follow a 'waterfall' model of software development  They assume that the requirements are fully understood by the customer 'up front'. They then proceed in a linear fashion through analysis, design, coding, testing, integration, deployment. Three years later you have the wrong product. I have yet to see a customer who truly understands their requirement 'up front'. Thats where RAD and Delphi come in. By involving the customer early through mock ups, you discover early the hidden requirements, the bogus ones, the contradictory ones, and you converge on an acceptable product. The first time a team of mine constructed a sizeable application in Delphi using a RAD approach, they turned the product around start to finish in six months. I'm predicting that the next time they will turn the product around in 3 months! Such is the power of Delphi. And it enchants developers, if you can get them to experience it. Thats the challenge however, getting them away from C++ long enough to try it. But I digress.</P>

<h3>OO and Software Engineering Tools</h3>
</B>
<P>So what constitutes software engineering anyway? Well, it is a disciplined approach to developing software, based upon following a process or methodology. It involves formally recording requirements, test cases, designs and the relationships (traceability) amongst them. It means archiving and controlling the versions of an emerging product, so that problems can be tracked to their point of origins, and so changes can be 'backed off' if required. It means formalizing the effort estimation process, using several different methods (including historical data) to predict the effort required in developing a new product. It also involves adopting coding standards, having peers review the developer's code, and applying sound project management techniques to the software development process, such as risk management. it means measuring both the product and the process to ensure things stay on track.</P>

<P>Since the popular growth of Object Oriented tools resulting from academic research in the area of software engineering, we can now add other tools to the SE arsenal. We now have widely accepted notation for OO concepts (UML). OO also encourages strategies already widely practiced in 'real' engineering disciplines, such as modular construction, re-use and design 'patterns'. And tools abound to support developers in applying these principals. The artifacts of the development process such as requirements, test cases, designs that were documents under the old 2167A standard are now maintained in tool databases. There are also tools for estimating, configuration management, problem and change tracking and measuring. At least one vendor is busy trying to connect all of these tools together to cover an 'end to end' process. Ok, so what ? </P>

<P>Believe me when I say that their is real value in this software engineering stuff. I have seen it work. However, most of the tools out there are focussed on supporting another vendors C++ and other languages, not Delphi. Oh sure, there are discrete tool offerings out there for Delphi, and some are very good, but there is no integration. They don't talk to each other. And that is why many companies are steering away from Delphi as a tooling choice and settling on other tools, other languages. But for many small operations and companies, the mom and pop shops, the integrated tool suites are out of the question. That's because they come with a hefty price tag, which by the time you are through could add up to $10K per seat. Clearly, only governments and big telecomm Corps can afford to pay this kind of ticket for these tools. </P>

<h3>Enter Delphi</h3>

<P>Enter Delphi. Delphi has an Open Tools API that could be a pivot point for a suite of low cost (or free ?) tools that could talk to the middleCASE AND each other. Some of these tools already have a good start. Look at FreeVCS (now <a href="http://jedivcs.sourceforge.net">JEDI VCS</a>). I switched to FreeVCS because of its full integration with Delphi. So far it has not let me down. And it has a slick GUI interface. And it is Delphi project manager aware, and it is fast, and it is Freeware! If such a complete toolset existed for Delphi, and you were a small firm or an independant consultant, what would you do ? Would you buy the expensive suite at $10K per pop, or would you buy Delphi (cheaper) with freeware add-ons ? What would that do to Delphi usage in North America ? Are the JEDI Knights going to slay the forces of darkness (lockin and high prices) and bring enlightenment (software engineering and tools) to the masses of enslaved ? Or with Darth Vader and his archangels continue to extract huge tithes ?</P>

<h3>What Tools ?</h3>

<P>The CM tool is already there. I mentioned FreeVCS. I am currently working on a documentation tool (not to be confused with a document tool). That is, it a collection of <B>articles</B> in a database. It is generic, so the kind of documentation it can hold is multiple : requirements, test cases, use cases, risks, problems, changes, etc. The concept includes maintaining the relationships between the 'documents'. So, a requirement maps to a use case, and to a test case(s). Test cases map to test results. Requirements to design, changes to design, etc. This is called a traceability matrix in 2167A parlance, represented here as a many to many relationship. The concept also includes the ability to establish hierarchies of articles, and attribute articles ie. what is the priority of this requirement. Is this a cosmetic requirement ? Does it specify performance? etc. There are templates for each kind of documentation so you don't start the attributes from scratch, and there are checklists to ensure nothing is forgotten. Sound intriguing enough ?</P>

<P>Metrics analyzer. Ok, these are product metrics in the first order. Some well accepted metrics are re-use (how many lines of code written by programmers<B> linked </B>vs lines of code created by Delphi, inherited from Delphi (VCL) or 3rd party add-ons), cyclomatic complexity (code that is complex will probably be hard to maintain ie sphagetti), Halstead's index (predicts the effort to code), coupling (effort and tolerance to change), etc. Believe me, these are good things to know, especially if you have to take over maintaining someone else's code !). Another common one (I think this would be easy to implement through the OTAPI) is comment density. Imagine you have a Software Tools Menu. You pick Product Metrics off the pull down list, and bingo, you have all these metrics before your very eyes ! Broken down by unit. Awesome !  Metrics help you build software by identifying problematic areas so they can be rewritten or more thoroughly tested. If programmers knew the re-use figures for Delphi they would be amazed at how much of the effort is saved through a well constructed VCL and the use of 3rd party components, but they don't. They can only guess.</P>

<P>What about a really good modeling tool. Conforms to the UML notational standard. Will build skeletal structure straight from the model, or reverse engineer an existing application (or back annotate, syncronize the model with the actual code). Is fully aware of the VCL, and can accept 3rd party component models as well ? Will take you right to the code in the editor that declares a class ? Will annotate methods with info already in the model (post and pre conditions for example). Have you heard that before? Probably yes, but not for free.</P>

<P>What about a work flow tool. Tracks problem reports, change requests through to completion ? Nothing falls through the cracks ? Coordinates the activity of multiple developers working on the same project. Keeps track of comments flowing back and forth ?</P>

<B><P>Strategy</P>
</B>
<P>&#9;To accomplish all this would require a legion of Knights. Personally I might be able to commit up to 8 hours per week to a project. If it is going to be do-able, I think you must keep it to a group of small teams, maybe three or four. I suspect that most Knights, like myself, have big egos. So putting a bunch of Knights on the same task is probably not a good idea. I like to 'own' what I work on. But I think if you had one group leader for each functional piece, along with a tester and documenter for example, and someone to oversee the whole architecture (as a shining example of such a collaboration the <a href="http://www.gexperts.org">GExperts project</a> comes to mind) then it would be do-able. </p>

<p>Impose some common look and feel for consistency across the suite. Have someone responsible for the repository 'back end'. Carefully control and define the interfaces Yes, it could be done. So that's my vision.</P>

<!-- --------------------------- -->
                </td>
              </tr>
            </table>
<!-- --------------------------- -->
          </td> 
        </tr>
      </table>

<!-- Footer -->

      <table> 
        <tr>
          <td colspan=2 align="center">
<a href="articles.html">
<img src="img/return_articles.gif" width=134 height=39 border=0></a> 
          </td>
        </tr>

        <tr>   
          <td>
<hr size=1>
This site and the pages contained within are Copyright © 1997-2006, Project JEDI.  Articles displayed or downloaded remain Copyright to their authors and may be used with the appropriate attribution.
<br><br>
For questions and comments regarding this site please contact webmaster-AT-delphi-jedi.org
          </td>
          <td align=center valign=middle>
<IMG HEIGHT=31 WIDTH=116 SRC="img/btn_jedinow.gif" BORDER=0 ALT="Jedi NOW!">
          </td>
        </tr>

        <tr>
          <td colspan="2">
<hr size="1">
            <table>
              <tr>
                <td valign="middle">
<A HREF="http://www.href.com/">
<img src="img/href_logo.gif" border=0></a>
                </td>
                <td>
<center>
Find software, books and training materials at our sponsor's site, www.href.com</center>
                </td>
              </tr>
            </table>

          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
</span>

</BODY>

</HTML>

